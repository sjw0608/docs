(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{147:function(t,r,e){"use strict";e.r(r);var o=e(0),a=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proxy","aria-hidden":"true"}},[t._v("#")]),t._v(" Proxy")]),t._v(" "),e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),e("p",[t._v("proxy 用于修改某些操作得默认行为，等同于在语言层面做出修改，属于一种‘元编程’（meta programming）,即对编程语言进行编程。可以理解为在目标对象之前架设一层‘拦截’，外界对该对象得访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界得访问进行过滤和修改。")]),t._v(" "),e("p",[t._v("ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" proxy "),e("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{attrs:{class:"token class-name"}},[t._v("Proxy")]),e("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),e("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" handler"),e("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("proxy 对象得所有用法，都是以上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。")]),t._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),e("p",[t._v("要使 Proxy 起作用，必须针对 Proxy 实力进行操作，而不是目标对象进行操作。\n如果 handler 没有设置任何拦截，那就等同于是直接通向元对象。")])]),t._v(" "),e("blockquote",[e("p",[t._v("小技巧：将 Proxy 对象设置到 object.proxy 属性，从而可以在 object 对象上调用")])]),t._v(" "),e("div",{staticClass:"warning custom-block"},[e("p",{staticClass:"custom-block-title"},[t._v("Proxy 支持的拦截操作:")]),t._v(" "),e("ul",[e("li",[t._v("get(target,propKey,receiver):拦截对象属性的读取，比如 proxy.foo 和 proxy['foo']")]),t._v(" "),e("li",[t._v("set(target,propKey,value,receiver):拦截对象属性的设置，比如 proxy.foo = v 或 proxy['foo'] = v,返回一个布尔值")]),t._v(" "),e("li",[t._v("has(target,propKey):拦截 propKey in proxy 的操作，返回一个布尔值")]),t._v(" "),e("li",[t._v("deleteProperty(target,propKey):拦截 delete proxy[propKey]的操作，返回一个布尔值")]),t._v(" "),e("li",[t._v("ownKeys(target):拦截 Object.getOwnPropertyNames(proxy)、bject.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的名，而 Object.keys()的返回结果仅包括目标对象自身可遍历属性")]),t._v(" "),e("li",[t._v("getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象")]),t._v(" "),e("li",[t._v("defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值")]),t._v(" "),e("li",[t._v("preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值")]),t._v(" "),e("li",[t._v("getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象")]),t._v(" "),e("li",[t._v("isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值")]),t._v(" "),e("li",[t._v("setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截")]),t._v(" "),e("li",[t._v("apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。")]),t._v(" "),e("li",[t._v("construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args)")])])]),t._v(" "),e("h2",{attrs:{id:"proxy-实例的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proxy-实例的方法","aria-hidden":"true"}},[t._v("#")]),t._v(" Proxy 实例的方法")]),t._v(" "),e("h3",{attrs:{id:"get"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get","aria-hidden":"true"}},[t._v("#")]),t._v(" get()")]),t._v(" "),e("p",[t._v("get 方法用于拦截某个属性的读取操作，可以接受三个参数，一次为目标对象、属性名 [和 proxy 实例本身（操作所针对的对象）]")])])}],!1,null,null,null);a.options.__file="proxy.md";r.default=a.exports}}]);