(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{155:function(v,_,t){"use strict";t.r(_);var i=t(0),e=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"一个页面从输入-url-到页面加载显示完成，这个过程中发生了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个页面从输入-url-到页面加载显示完成，这个过程中发生了什么？","aria-hidden":"true"}},[v._v("#")]),v._v(" 一个页面从输入 URL 到页面加载显示完成，这个过程中发生了什么？")]),v._v(" "),t("ul",[t("li",[v._v("DNS 解析")]),v._v(" "),t("li",[v._v("TCP 链接")]),v._v(" "),t("li",[v._v("发送 HTTP 请求")]),v._v(" "),t("li",[v._v("服务器处理请求返回 HTTP 报文")]),v._v(" "),t("li",[v._v("浏览器解析渲染页面")]),v._v(" "),t("li",[v._v("链接结束")])]),v._v(" "),t("h2",{attrs:{id:"dns-domain-name-system，域名系统-解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dns-domain-name-system，域名系统-解析","aria-hidden":"true"}},[v._v("#")]),v._v(" DNS(Domain Name System，域名系统)解析")]),v._v(" "),t("p",[v._v("DNS 解析的过程就是寻找哪台机器上有你需要资源的过程。"),t("strong",[v._v("网址到 IP 的转换")])]),v._v(" "),t("h2",{attrs:{id:"tcp-链接-三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-链接-三次握手","aria-hidden":"true"}},[v._v("#")]),v._v(" TCP 链接(三次握手)")]),v._v(" "),t("p",[v._v("通信连接的建立需要经历以下三个过程： "),t("br")]),v._v(" "),t("ul",[t("li",[v._v("主机向服务器发送一个建立链接的请求")]),v._v(" "),t("li",[v._v("服务器接到请求后发送同意链接的信号")]),v._v(" "),t("li",[v._v("主机接到同意请求的信号后，再次向服务器发送确认信号，自此，主机与服务器两者建立链接\n("),t("em",[v._v("三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号")]),v._v(")")])]),v._v(" "),t("h2",{attrs:{id:"发送-http-请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送-http-请求","aria-hidden":"true"}},[v._v("#")]),v._v(" 发送 HTTP 请求")]),v._v(" "),t("p",[v._v("当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。\n浏览器根据 URL 内容生成 HTTP 请求，HTTP 请求报文是由三部分组成: 请求行, 请求报头和请求正文")]),v._v(" "),t("h2",{attrs:{id:"服务器处理请求并返回-http-报文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务器处理请求并返回-http-报文","aria-hidden":"true"}},[v._v("#")]),v._v(" 服务器处理请求并返回 HTTP 报文")]),v._v(" "),t("p",[v._v("服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；\n服务器将得到的 HTML 文件发送给浏览器；\nHTTP 响应报文也是由三部分组成: 状态码, 响应报头和响应报文")]),v._v(" "),t("ul",[t("li",[v._v("1 状态吗\n"),t("ul",[t("li",[v._v("1XX: 指示信息-表示请求已连接，继续处理")]),v._v(" "),t("li",[v._v("2XX：成功-表示请求已被成功接受")]),v._v(" "),t("li",[v._v("3XX：重定向-要完成请求必须进行更进一步的操作")]),v._v(" "),t("li",[v._v("4XX：客户端错误-请求有语法错误或请求无法实现")]),v._v(" "),t("li",[v._v("5XX：服务器端错误-服务器未能实现合法的请求")])])]),v._v(" "),t("li",[v._v("2 响应报头\n"),t("ul",[t("li",[v._v("常见的响应包头字段有：Server，Connection...")])])]),v._v(" "),t("li",[v._v("3 响应报文\n"),t("ul",[t("li",[v._v("服务器返回给浏览器的文本信息，通常 HTML、CSS、JS，图片等文件放在这部分")])])])]),v._v(" "),t("h2",{attrs:{id:"浏览器解析渲染页面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析渲染页面","aria-hidden":"true"}},[v._v("#")]),v._v(" 浏览器解析渲染页面")]),v._v(" "),t("p",[v._v("在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript 等文件，过程同请求 HTML\n"),t("br"),v._v("\n浏览器是一个便解析便渲染的过程。首先浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染是并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念："),t("strong",[v._v("reflow（回流）"),t("strong",[v._v("和")]),v._v("repain（重绘）")]),v._v("。页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。\n"),t("br"),v._v(" "),t("br"),v._v("\nJS 的解析是由浏览器中的 JS 解析引擎完成的。JS 是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。\n"),t("br"),v._v(" "),t("br"),v._v("\n浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS 等。浏览器将重复 1-6 过程下载该资源。请求过程是异步的，并不会影响 HTML 文档进行加载，但是当文档加载过程中遇到 JS 件，HTML 文档会挂起渲染过程，不仅要等到文档中 JS 文件加载完毕还要等待解析执行完毕，才会继续 HTML 的渲染过程。原因是因为 JS 有可能修改 DOM 结构，这就意味着 JS 执行完成前，后续所有源的下载是没有必要的，这就是 JS 阻塞后续资源下载的根本原因。CSS 文件的加载不影响 JS 文件的加载，但是却影响 JS 文件的执行。JS 代码执行前浏览器必须保证 CSS 文件已经下载并加载完毕")]),v._v(" "),t("h2",{attrs:{id:"连接结束"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接结束","aria-hidden":"true"}},[v._v("#")]),v._v(" 连接结束")]),v._v(" "),t("ul",[t("li",[v._v("主机向服务器发送一个断开链接的请求")]),v._v(" "),t("li",[v._v("服务器接到请求后发送确认收到请求的信号")]),v._v(" "),t("li",[v._v("服务器向主机发送断开通知")]),v._v(" "),t("li",[v._v("主机连接断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("reflow（回流）"),t("strong",[v._v("和")]),v._v("repain（重绘）")])])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("reflow（回流）")]),v._v("：当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流\n"),t("ul",[t("li",[v._v("会导致回流的操作\n"),t("ul",[t("li",[v._v("页面首次渲染")]),v._v(" "),t("li",[v._v("浏览器窗口大小的改变")]),v._v(" "),t("li",[v._v("元素尺寸或位置发生变化")]),v._v(" "),t("li",[v._v("元素内容变化（文字数量或图片大小等等）")]),v._v(" "),t("li",[v._v("元素字体大小的变化")]),v._v(" "),t("li",[v._v("添加或者删除可见的"),t("code",[v._v("DOM")]),v._v("元素")]),v._v(" "),t("li",[v._v("激活"),t("code",[v._v("CSS")]),v._v("伪类（例如："),t("code",[v._v(":hover")]),v._v("）")]),v._v(" "),t("li",[v._v("查询某些属性或调用某些方法")])])]),v._v(" "),t("li",[v._v("一些常用且会导致回流的属性和方法\n"),t("ul",[t("li",[v._v("clientWidth、clientHeight、clientTop、clientLeft")]),v._v(" "),t("li",[v._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),v._v(" "),t("li",[v._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),v._v(" "),t("li",[v._v("scrollIntoView()、scrollIntoViewIfNeeded()")]),v._v(" "),t("li",[v._v("getComputedStyle()")]),v._v(" "),t("li",[v._v("getBoundingClientRect()")]),v._v(" "),t("li",[v._v("scrollTo()")])])])])]),v._v(" "),t("li",[t("strong",[v._v("repain（重绘）")]),v._v(": 页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),v._v(" "),t("li",[t("strong",[v._v("性能影响")]),v._v(": 回流比重绘的代价更高("),t("em",[v._v("有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。")]),v._v(") "),t("br"),v._v(" "),t("strong",[v._v("现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。")])]),v._v(" "),t("li",[t("strong",[v._v("如何避免")]),v._v(" "),t("ul",[t("li",[v._v("CSS\n"),t("ul",[t("li",[v._v("避免使用 table 布局")]),v._v(" "),t("li",[v._v("尽量可能在 DOM 树的最末端改变 class")]),v._v(" "),t("li",[v._v("避免设置多层内联样式")]),v._v(" "),t("li",[v._v("将动画效果应用到"),t("code",[v._v("position")]),v._v("属性为"),t("code",[v._v("absolute")]),v._v("或"),t("code",[v._v("fixed")]),v._v("的元素上")]),v._v(" "),t("li",[v._v("避免使用"),t("code",[v._v("CSS")]),v._v("表达式（例如："),t("code",[v._v("calc()")]),v._v("）")])])]),v._v(" "),t("li",[v._v("JavaScript\n"),t("ul",[t("li",[v._v("避免频繁的操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性")]),v._v(" "),t("li",[v._v("避免频繁的操作 DOM，创建一个"),t("code",[v._v("documentFragment")]),v._v("，在它上面应用所有的 DOM 操作，最后再把它添加到文档中")]),v._v(" "),t("li",[v._v("先为元素设置"),t("code",[v._v("display：none")]),v._v("，操作结束后再把它显示出来。因为"),t("code",[v._v("dispaly")]),v._v("属性为"),t("code",[v._v("none")]),v._v("的元素上进行 DOM 操作不会引发回流和重绘")]),v._v(" "),t("li",[v._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多此使用，就用一个变量缓存起来")]),v._v(" "),t("li",[v._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流")])])])])])])])}],!1,null,null,null);e.options.__file="urlStep.md";_.default=e.exports}}]);